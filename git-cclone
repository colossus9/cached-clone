#!/usr/bin/env bash
#/ Usage: git cclone <repo-url> <cache-dir> <working-copy-dir> <ref>
#/
#/ Clone a repository and leverage a local cache. Git submodules and
#/ Git LFS files are cached as well.
#/
#/ Attention the <working-copy-dir> is always purged!
#/
#/ Known issues:
#/  - only one level of Submodules are processed
#/
#/ Examples:
#/
#/   Clone and checkout the master branch:
#/   $ git cclone http://myrepo.git /cache /repo master
#/
#/   Clone and checkout a PR head:
#/   $ git cclone <repo-url> <cache-dir> <working-copy-dir> pull/<pr-id>/head
#/
#/   Clone and checkout a PR merge:
#/   $ git cclone <repo-url> <cache-dir> <working-copy-dir> pull/<pr-id>/merge
#/

CCLONE_VERSION='v0.0.2'

# Abort the script if a single command fails.
set -e

if [ "$#" -ne 4 ]; then
    grep '^#/' < "$0" | cut -c 4-
    exit 2
fi

# Check if $DEBUG variable is defined (e.g. with "export DEBUG=1")
# If it is defined, then print all commands executed by this script
# and all internal commands executed by Git.
if [[ -n "$DEBUG" ]]; then
    set -x
    export GIT_TRACE=1
    QUIET_FLAG=''
else
    QUIET_FLAG='--quiet'
fi

# Calculate the absolute path (realpath might not be available on macOS)
realpath() {
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

# Helper functions to print output
function log {
    printf "\n>>> $1\n"
}

function err {
    printf "ERROR: $1\n"
}

# Helper function that retries a command if it failed.
# This is useful for Git commands that perform network requests as
# network requests can always fail.
function git_retry {
    local remote=$1
    local ref=$2
    local git_dir=$3
    local retries=7   # longest continuous wait should be 64s (2**6)
    local count=1     # first try after 4s, if needed
    local ret=1       # make command overwrite this
    while [ $count -lt $retries ]; do
        set +e
        git "$@"
        ret=$?
        set -e
        if [ $ret -eq 0 ]; then
            break
        fi
        count=$((count+1))
        local delay=$((2**count))
        sleep $delay
    done
    if [ $ret -gt 0 ]; then
        err "git failed with exit code '$ret'"
        exit $ret
    fi
}

GIT_REMOTE=$1
GIT_CACHE=$(realpath $2)
WORKING_COPY=$(realpath $3)
REF=$4

SHARED_CONFIG="$GIT_CACHE/shared-config"
MAIN_SHA1=""
SECONDS=0

if [[ $REF != pull/* ]]; then
    REF="heads/$REF"
fi

log "Cached Clone $CCLONE_VERSION"
echo "Start date:   $(date)"
echo "Cache:        $GIT_CACHE"
echo "Working Copy: $WORKING_COPY"
git --version
git lfs version

mkdir -p "$GIT_CACHE"
pushd "$GIT_CACHE" >/dev/null

    # Create cache if it does not exist yet
    if [ -z "$(ls -A . 2>/dev/null)" ]; then
        log 'Initializing Cache'

        git init $QUIET_FLAG --bare .

        # We create the shared-config only on cache creation to avoid problems
        # if multiple parallel cclone run share the same cache.
        cat <<EOM >"$SHARED_CONFIG"
            [core]
                # Enable file system cache on Windows (no effect on OS X/Linux)
                # c.f. https://groups.google.com/forum/#!topic/git-for-windows/9WrSosaa4A8
                fscache = true

                # Enable long path support for Windows (no effect on OS X/Linux)
                # Git uses the proper API to create long paths on Windows.
                # However, many Windows applications use an outdated API that
                # only support paths up to a length of 260 characters. As a
                # result these applications would not be able to work with the
                # longer paths properly. Keep that in mind if you run into path
                # trouble!
                # c.f. https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx
                longpaths = true

            [gc]
                # Disable all garbage collection. Objects that cannot be referenced
                # in the share objects directory might belong to another repo that
                # is using the cache.
                auto = 0
                pruneExpire = never
                reflogExpire = never

            [lfs]
                batch = true
                concurrentTransfers = 10
                storage = $GIT_CACHE/lfs

                # If the Git LFS locking feature is used, then Git LFS will set
                # lockable files to "readonly" by default. This is implemented
                # with a Git LFS "post-checkout" hook. Git LFS can skip this
                # hook if no file is locked. However, Git LFS needs to traverse
                # the entire tree to find all ".gitattributes" and check for
                # locked files. In a large tree this can take a while. Instruct
                # Git LFS to not set lockable files to "readonly" as this is
                # not necessary for a CI system.
                setLockableReadonly = false

            [lfs "transfer"]
                maxretries = 10

            [filter "lfs"]
                clean = git-lfs clean -- %f
                smudge = git-lfs smudge -- %f
                process = git-lfs filter-process
                required = true
EOM
        git config --local include.path $SHARED_CONFIG
    fi

    log "Updating Cache"
    main_remote_name=$(git hash-object <(echo "$GIT_REMOTE"))
    git_retry fetch --force --no-tags $GIT_REMOTE \
        "refs/$REF:refs/remotes/$main_remote_name/$REF"
    MAIN_SHA1=$(git rev-parse refs/remotes/$main_remote_name/$REF)
    git lfs fetch $GIT_REMOTE $MAIN_SHA1

popd >/dev/null

log "Preparing Checkout"
rm -rf "$WORKING_COPY"
mkdir -p "$WORKING_COPY"
pushd "$WORKING_COPY" >/dev/null

    git clone $QUIET_FLAG --reference "$GIT_CACHE" --no-checkout "$GIT_CACHE" .
    git -c include.path=$SHARED_CONFIG \
        checkout $QUIET_FLAG --force --detach $MAIN_SHA1

    git submodule sync --recursive
    git submodule--helper list |
        while read mode sm_sha1 stage sm_path
        do
            git submodule $QUIET_FLAG init -- "$sm_path"

            sm_name=$(git submodule--helper name "$sm_path")
            sm_relpath=$(git submodule--helper relative-path $sm_name '')
            sm_url=$(git config submodule.$sm_name.url)
            sm_remote_name=$(git hash-object <(echo "$sm_url"))
            sm_gitdir=".git/modules/$sm_name"
            mkdir -p .git/modules

            pushd "$GIT_CACHE" >/dev/null
                log "Updating Cache (Submodule '$sm_path')"
                git_retry fetch --force --no-tags $sm_url \
                        "refs/heads/*:refs/remotes/$sm_remote_name/heads/*"
                git lfs fetch $sm_url $sm_sha1
            popd >/dev/null

            log "Preparing Checkout (Submodule '$sm_path')"
            git clone \
              $QUIET_FLAG \
              --reference "$GIT_CACHE" \
              --separate-git-dir="$sm_gitdir" \
              --no-checkout \
              "$GIT_CACHE" "$sm_relpath"
            git --git-dir="$sm_gitdir" --work-tree="$sm_relpath" \
                -c include.path=$SHARED_CONFIG \
                checkout $QUIET_FLAG --force --detach $sm_sha1
        done

popd >/dev/null

log "Runtime (sec): $SECONDS"
log "Success!"
